---
description: Python and FastAPI patterns
globs: "**/*.py"
alwaysApply: false
---

# Python / FastAPI Standards

## Project Structure

```
backend/
├── api/
│   ├── __init__.py
│   ├── routes/
│   │   ├── __init__.py
│   │   ├── users.py
│   │   └── sessions.py
│   └── dependencies.py
├── services/
│   ├── __init__.py
│   ├── user_service.py
│   └── session_service.py
├── models/
│   ├── __init__.py
│   └── user.py
├── schemas/
│   ├── __init__.py
│   └── user.py
├── tests/
│   ├── __init__.py
│   └── test_users.py
├── main.py
└── config.py
```

## Type Hints

### REQUIRED

1. **All functions must have type hints**
   ```python
   # CORRECT
   def get_user(user_id: str) -> User | None:
       pass
   
   # WRONG
   def get_user(user_id):
       pass
   ```

2. **Use modern type syntax (Python 3.10+)**
   ```python
   # CORRECT
   def process(items: list[str]) -> dict[str, int]:
       pass
   
   # WRONG - old style
   from typing import List, Dict
   def process(items: List[str]) -> Dict[str, int]:
       pass
   ```

3. **Use Pydantic for data validation**
   ```python
   from pydantic import BaseModel
   
   class UserCreate(BaseModel):
       name: str
       email: str
   
   class User(BaseModel):
       id: str
       name: str
       email: str
       
       class Config:
           from_attributes = True
   ```

## FastAPI Routes

### Route Structure

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from ..dependencies import get_db
from ..schemas.user import User, UserCreate
from ..services import user_service

router = APIRouter(prefix="/users", tags=["users"])

@router.get("/{user_id}", response_model=User)
async def get_user(
    user_id: str,
    db: Session = Depends(get_db)
) -> User:
    user = await user_service.get_user(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"User {user_id} not found"
        )
    return user

@router.post("/", response_model=User, status_code=status.HTTP_201_CREATED)
async def create_user(
    user_data: UserCreate,
    db: Session = Depends(get_db)
) -> User:
    return await user_service.create_user(db, user_data)
```

### FORBIDDEN in Routes

1. **Business logic in routes** (use services)
   ```python
   # WRONG
   @router.post("/")
   async def create_user(user_data: UserCreate, db: Session = Depends(get_db)):
       # Business logic directly in route
       if await db.query(User).filter(User.email == user_data.email).first():
           raise HTTPException(400, "Email exists")
       user = User(**user_data.dict())
       db.add(user)
       db.commit()
       return user
   
   # CORRECT - delegate to service
   @router.post("/")
   async def create_user(user_data: UserCreate, db: Session = Depends(get_db)):
       return await user_service.create_user(db, user_data)
   ```

2. **Direct database access** (use services)

3. **Synchronous database calls**
   ```python
   # WRONG
   def get_users():
       return db.query(User).all()
   
   # CORRECT
   async def get_users():
       return await db.execute(select(User))
   ```

## Services

```python
# services/user_service.py

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from ..models.user import User
from ..schemas.user import UserCreate

async def get_user(db: AsyncSession, user_id: str) -> User | None:
    result = await db.execute(select(User).where(User.id == user_id))
    return result.scalar_one_or_none()

async def create_user(db: AsyncSession, user_data: UserCreate) -> User:
    user = User(**user_data.model_dump())
    db.add(user)
    await db.commit()
    await db.refresh(user)
    return user
```

## Error Handling

```python
from fastapi import HTTPException, status

class AppException(Exception):
    def __init__(self, message: str, code: str, status_code: int = 500):
        self.message = message
        self.code = code
        self.status_code = status_code
        super().__init__(message)

class NotFoundError(AppException):
    def __init__(self, resource: str, id: str):
        super().__init__(
            message=f"{resource} {id} not found",
            code="NOT_FOUND",
            status_code=404
        )

class ValidationError(AppException):
    def __init__(self, message: str):
        super().__init__(
            message=message,
            code="VALIDATION_ERROR",
            status_code=400
        )

# In main.py
@app.exception_handler(AppException)
async def app_exception_handler(request: Request, exc: AppException):
    return JSONResponse(
        status_code=exc.status_code,
        content={"error": exc.code, "message": exc.message}
    )
```

## Configuration

```python
# config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    database_url: str
    secret_key: str
    debug: bool = False
    
    class Config:
        env_file = ".env"

settings = Settings()
```

## Testing

```python
# tests/test_users.py
import pytest
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession

from ..main import app

@pytest.fixture
async def client():
    async with AsyncClient(app=app, base_url="http://test") as client:
        yield client

@pytest.mark.asyncio
async def test_create_user(client: AsyncClient):
    response = await client.post(
        "/users/",
        json={"name": "Test User", "email": "test@example.com"}
    )
    assert response.status_code == 201
    data = response.json()
    assert data["name"] == "Test User"
    assert "id" in data

@pytest.mark.asyncio
async def test_get_user_not_found(client: AsyncClient):
    response = await client.get("/users/nonexistent")
    assert response.status_code == 404
```

## Naming Conventions

| Type | Convention | Example |
|------|------------|---------|
| Modules | snake_case | `user_service.py` |
| Classes | PascalCase | `UserService` |
| Functions | snake_case | `get_user()` |
| Variables | snake_case | `user_count` |
| Constants | UPPER_SNAKE | `MAX_RETRIES` |
| Pydantic models | PascalCase | `UserCreate` |
