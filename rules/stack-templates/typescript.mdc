---
description: TypeScript standards and patterns
globs: "**/*.ts,**/*.tsx"
alwaysApply: true
---

# TypeScript Standards

## Why TypeScript

TypeScript catches errors at compile time before they reach users. It makes refactoring safer and provides better IDE support.

## Configuration

Use strict mode. No exceptions.

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true
  }
}
```

## Type Rules

### REQUIRED

1. **Explicit return types on all functions**
   ```typescript
   // CORRECT
   function getUser(id: string): Promise<User | null> { }
   
   // WRONG
   function getUser(id: string) { }
   ```

2. **Interfaces for all data structures**
   ```typescript
   // CORRECT
   interface User {
     id: string;
     name: string;
     email: string;
   }
   
   // WRONG - inline types scattered everywhere
   function process(data: { id: string; name: string }) { }
   ```

3. **Use `unknown` instead of `any` for truly unknown types**
   ```typescript
   // CORRECT
   function parseJSON(text: string): unknown { }
   
   // WRONG
   function parseJSON(text: string): any { }
   ```

4. **Null checks explicit**
   ```typescript
   // CORRECT
   if (user !== null && user !== undefined) { }
   // or
   if (user != null) { }  // checks both null and undefined
   
   // WRONG - relying on truthy/falsy
   if (user) { }  // fails for empty string, 0, etc.
   ```

### FORBIDDEN

1. **`@ts-ignore` without explanation**
   ```typescript
   // WRONG
   // @ts-ignore
   doSomething(badData);
   
   // ACCEPTABLE (rare cases only)
   // @ts-ignore - Third-party library has incorrect types, see issue #123
   doSomething(badData);
   ```

2. **`as any` casts**
   ```typescript
   // WRONG
   const data = response as any;
   
   // CORRECT - use type guards or proper typing
   if (isUser(response)) {
     const data = response;
   }
   ```

3. **Disabling strict checks in tsconfig**

4. **Using `!` non-null assertion without justification**
   ```typescript
   // WRONG
   const name = user!.name;
   
   // CORRECT
   if (user) {
     const name = user.name;
   }
   ```

## Naming Conventions

| Type | Convention | Example |
|------|------------|---------|
| Interfaces | PascalCase | `User`, `CoachingSession` |
| Type aliases | PascalCase | `UserRole`, `SessionState` |
| Enums | PascalCase | `SessionStatus` |
| Enum values | UPPER_SNAKE | `SessionStatus.IN_PROGRESS` |
| Functions | camelCase | `getUser`, `createSession` |
| Variables | camelCase | `currentUser`, `sessionCount` |
| Constants | UPPER_SNAKE | `MAX_RETRIES`, `API_BASE_URL` |

## Utility Types

Use built-in utility types:

```typescript
// Partial - all properties optional
function updateUser(id: string, updates: Partial<User>): Promise<User>

// Pick - subset of properties
type UserPreview = Pick<User, 'id' | 'name'>

// Omit - exclude properties
type CreateUserInput = Omit<User, 'id' | 'createdAt'>

// Required - all properties required
type CompleteUser = Required<User>
```

## Error Handling

```typescript
// Define custom error types
class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 500
  ) {
    super(message);
    this.name = 'AppError';
  }
}

// Use Result types for expected failures
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };
```

## Imports

```typescript
// CORRECT - explicit imports
import { User, Session } from '@/types';
import { getUser } from '@/services/user';

// WRONG - wildcard imports (harder to tree-shake)
import * as types from '@/types';
```

## Why Strict TypeScript

TypeScript catches bugs at compile time that would otherwise surface in production.

**Specific benefits:**
- `strict: true` catches null/undefined errors before they crash
- Explicit return types document function contracts
- `unknown` instead of `any` forces safe type narrowing
- Refactoring is safeâ€”the compiler tells you what broke
